conflict没有必要搜索那么远吧，可以考虑用二分查找，但是优化似乎不大。
日志不一致问题？？？没看出原因
选举超时定时器出错问题已经优化。


2B:
TestFailAgree2B、TestRPCBytes2B、TestBasicAgree2B
1. 背着已经当选leader的节点自己选了一个leader出来，原先的节点可能已经接收了请求，在节点信息同步后被迫放弃了请求日志的复制，这个问题很早就发现了，一直得不到解决。从Make开始震荡了约0.8s才选出稳定的leader。


2C:
1. matchIndex超出边界——leader在HAE中才更新matchIndex，而每一次成功的AE都要在HAE中检查是否需要commit，检查就会用到matchIndex，那么getTerm(N)就可能会越界访问（leader的matchIndex是旧的，当前leader的日志因为曾经是follower被抹去过）。解决方法就是在leader上台时针对matchIndex做初始化。教训就是初始化和数组越界的严格检查！
2. 日志未达成一致问题，没查出来；怀疑定时器不正常启停，导致重复选举问题，测试8s多才启动？？
3. 老问题：定时器重置和超时十分接近，如果定时器超时的时候在进行定时器重置，如何进行操作？因为互斥锁的阻塞原因，所以即使定时器到期，如果没有获取到锁就会阻塞不进行选举操作，那么在阻塞期间对定时器进行重置仅仅stop是无效的，要采取正确措施告知ticker已经被正确重置了
4.刚发现日志更新的结点无法快速转变未candidate导致选不出leader（三个节点中有一个节点日志更新，该节点的定时器不断被其他节点的投票请求重置，而且定时器时间还比较大，导致一直没有超时）
2D:
1. 发现SE内的协程处理投票返回结果和HAE同时在进行，SE里面的go协程忘记上锁了，导致数据竟态，协程意外更新了Term，而HAE仍然在进行，错误地进行了reply.Term == rf.currentTerm分支而不是reply.Term > rf.currentTerm分支。注意并发的锁问题。


24.9.12
已经能够稳定通过2C、2D测试千次，2B暴露的问题暂时可以忽略